// Code generated by fastssz. DO NOT EDIT.
// Hash: a0dae63eb54e425273196828e076eb25245229bfc7107a06ec3d480951ea7349
// Version: 0.1.3
package exporter

import (
	"github.com/attestantio/go-eth2-client/spec/phase0"
	ssz "github.com/ferranbt/fastssz"
	spectypes "github.com/ssvlabs/ssv-spec/types"
)

// MarshalSSZ ssz marshals the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the ValidatorDutyTrace object to a target array
func (v *ValidatorDutyTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(36)

	// Field (0) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(v.Slot))

	// Offset (1) 'Rounds'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(v.Rounds); ii++ {
		offset += 4
		offset += v.Rounds[ii].SizeSSZ()
	}

	// Offset (2) 'Pre'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(v.Pre) * 56

	// Offset (3) 'Post'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(v.Post) * 56

	// Field (4) 'Role'
	dst = ssz.MarshalUint64(dst, uint64(v.Role))

	// Field (5) 'Validator'
	dst = ssz.MarshalUint64(dst, uint64(v.Validator))

	// Field (1) 'Rounds'
	if size := len(v.Rounds); size > 15 {
		err = ssz.ErrListTooBigFn("ValidatorDutyTrace.Rounds", size, 15)
		return
	}
	{
		offset = 4 * len(v.Rounds)
		for ii := 0; ii < len(v.Rounds); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += v.Rounds[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(v.Rounds); ii++ {
		if dst, err = v.Rounds[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (2) 'Pre'
	if size := len(v.Pre); size > 13 {
		err = ssz.ErrListTooBigFn("ValidatorDutyTrace.Pre", size, 13)
		return
	}
	for ii := 0; ii < len(v.Pre); ii++ {
		if dst, err = v.Pre[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (3) 'Post'
	if size := len(v.Post); size > 13 {
		err = ssz.ErrListTooBigFn("ValidatorDutyTrace.Post", size, 13)
		return
	}
	for ii := 0; ii < len(v.Post); ii++ {
		if dst, err = v.Post[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 36 {
		return ssz.ErrSize
	}

	tail := buf
	var o1, o2, o3 uint64

	// Field (0) 'Slot'
	v.Slot = phase0.Slot(ssz.UnmarshallUint64(buf[0:8]))

	// Offset (1) 'Rounds'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 36 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (2) 'Pre'
	if o2 = ssz.ReadOffset(buf[12:16]); o2 > size || o1 > o2 {
		return ssz.ErrOffset
	}

	// Offset (3) 'Post'
	if o3 = ssz.ReadOffset(buf[16:20]); o3 > size || o2 > o3 {
		return ssz.ErrOffset
	}

	// Field (4) 'Role'
	v.Role = spectypes.BeaconRole(ssz.UnmarshallUint64(buf[20:28]))

	// Field (5) 'Validator'
	v.Validator = phase0.ValidatorIndex(ssz.UnmarshallUint64(buf[28:36]))

	// Field (1) 'Rounds'
	{
		buf = tail[o1:o2]
		num, err := ssz.DecodeDynamicLength(buf, 15)
		if err != nil {
			return err
		}
		v.Rounds = make([]*RoundTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if v.Rounds[indx] == nil {
				v.Rounds[indx] = new(RoundTrace)
			}
			if err = v.Rounds[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (2) 'Pre'
	{
		buf = tail[o2:o3]
		num, err := ssz.DivideInt2(len(buf), 56, 13)
		if err != nil {
			return err
		}
		v.Pre = make([]*MessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if v.Pre[ii] == nil {
				v.Pre[ii] = new(MessageTrace)
			}
			if err = v.Pre[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}

	// Field (3) 'Post'
	{
		buf = tail[o3:]
		num, err := ssz.DivideInt2(len(buf), 56, 13)
		if err != nil {
			return err
		}
		v.Post = make([]*MessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if v.Post[ii] == nil {
				v.Post[ii] = new(MessageTrace)
			}
			if err = v.Post[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) SizeSSZ() (size int) {
	size = 36

	// Field (1) 'Rounds'
	for ii := 0; ii < len(v.Rounds); ii++ {
		size += 4
		size += v.Rounds[ii].SizeSSZ()
	}

	// Field (2) 'Pre'
	size += len(v.Pre) * 56

	// Field (3) 'Post'
	size += len(v.Post) * 56

	return
}

// HashTreeRoot ssz hashes the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the ValidatorDutyTrace object with a hasher
func (v *ValidatorDutyTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(v.Slot))

	// Field (1) 'Rounds'
	{
		subIndx := hh.Index()
		num := uint64(len(v.Rounds))
		if num > 15 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range v.Rounds {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 15)
	}

	// Field (2) 'Pre'
	{
		subIndx := hh.Index()
		num := uint64(len(v.Pre))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range v.Pre {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (3) 'Post'
	{
		subIndx := hh.Index()
		num := uint64(len(v.Post))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range v.Post {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (4) 'Role'
	hh.PutUint64(uint64(v.Role))

	// Field (5) 'Validator'
	hh.PutUint64(uint64(v.Validator))

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(v)
}

// MarshalSSZ ssz marshals the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the CommitteeDutyTrace object to a target array
func (c *CommitteeDutyTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(116)

	// Field (0) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(c.Slot))

	// Offset (1) 'Rounds'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(c.Rounds); ii++ {
		offset += 4
		offset += c.Rounds[ii].SizeSSZ()
	}

	// Offset (2) 'Post'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(c.Post); ii++ {
		offset += 4
		offset += c.Post[ii].SizeSSZ()
	}

	// Field (3) 'CommitteeID'
	dst = append(dst, c.CommitteeID[:]...)

	// Offset (4) 'OperatorIDs'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.OperatorIDs) * 8

	// Field (5) 'AttestationDataRoot'
	dst = append(dst, c.AttestationDataRoot[:]...)

	// Field (6) 'SyncCommitteeMessageRoot'
	dst = append(dst, c.SyncCommitteeMessageRoot[:]...)

	// Field (1) 'Rounds'
	if size := len(c.Rounds); size > 15 {
		err = ssz.ErrListTooBigFn("CommitteeDutyTrace.Rounds", size, 15)
		return
	}
	{
		offset = 4 * len(c.Rounds)
		for ii := 0; ii < len(c.Rounds); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += c.Rounds[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(c.Rounds); ii++ {
		if dst, err = c.Rounds[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (2) 'Post'
	if size := len(c.Post); size > 13 {
		err = ssz.ErrListTooBigFn("CommitteeDutyTrace.Post", size, 13)
		return
	}
	{
		offset = 4 * len(c.Post)
		for ii := 0; ii < len(c.Post); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += c.Post[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(c.Post); ii++ {
		if dst, err = c.Post[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (4) 'OperatorIDs'
	if size := len(c.OperatorIDs); size > 13 {
		err = ssz.ErrListTooBigFn("CommitteeDutyTrace.OperatorIDs", size, 13)
		return
	}
	for ii := 0; ii < len(c.OperatorIDs); ii++ {
		dst = ssz.MarshalUint64(dst, uint64(c.OperatorIDs[ii]))
	}

	return
}

// UnmarshalSSZ ssz unmarshals the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 116 {
		return ssz.ErrSize
	}

	tail := buf
	var o1, o2, o4 uint64

	// Field (0) 'Slot'
	c.Slot = phase0.Slot(ssz.UnmarshallUint64(buf[0:8]))

	// Offset (1) 'Rounds'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 116 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (2) 'Post'
	if o2 = ssz.ReadOffset(buf[12:16]); o2 > size || o1 > o2 {
		return ssz.ErrOffset
	}

	// Field (3) 'CommitteeID'
	copy(c.CommitteeID[:], buf[16:48])

	// Offset (4) 'OperatorIDs'
	if o4 = ssz.ReadOffset(buf[48:52]); o4 > size || o2 > o4 {
		return ssz.ErrOffset
	}

	// Field (5) 'AttestationDataRoot'
	copy(c.AttestationDataRoot[:], buf[52:84])

	// Field (6) 'SyncCommitteeMessageRoot'
	copy(c.SyncCommitteeMessageRoot[:], buf[84:116])

	// Field (1) 'Rounds'
	{
		buf = tail[o1:o2]
		num, err := ssz.DecodeDynamicLength(buf, 15)
		if err != nil {
			return err
		}
		c.Rounds = make([]*RoundTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if c.Rounds[indx] == nil {
				c.Rounds[indx] = new(RoundTrace)
			}
			if err = c.Rounds[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (2) 'Post'
	{
		buf = tail[o2:o4]
		num, err := ssz.DecodeDynamicLength(buf, 13)
		if err != nil {
			return err
		}
		c.Post = make([]*CommitteeMessageTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if err = c.Post[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (4) 'OperatorIDs'
	{
		buf = tail[o4:]
		num, err := ssz.DivideInt2(len(buf), 8, 13)
		if err != nil {
			return err
		}
		c.OperatorIDs = ssz.ExtendUint64(c.OperatorIDs, num)
		for ii := 0; ii < num; ii++ {
			c.OperatorIDs[ii] = spectypes.OperatorID(ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8]))
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) SizeSSZ() (size int) {
	size = 116

	// Field (1) 'Rounds'
	for ii := 0; ii < len(c.Rounds); ii++ {
		size += 4
		size += c.Rounds[ii].SizeSSZ()
	}

	// Field (2) 'Post'
	for ii := 0; ii < len(c.Post); ii++ {
		size += 4
		size += c.Post[ii].SizeSSZ()
	}

	// Field (4) 'OperatorIDs'
	size += len(c.OperatorIDs) * 8

	return
}

// HashTreeRoot ssz hashes the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the CommitteeDutyTrace object with a hasher
func (c *CommitteeDutyTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(c.Slot))

	// Field (1) 'Rounds'
	{
		subIndx := hh.Index()
		num := uint64(len(c.Rounds))
		if num > 15 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range c.Rounds {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 15)
	}

	// Field (2) 'Post'
	{
		subIndx := hh.Index()
		num := uint64(len(c.Post))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range c.Post {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (3) 'CommitteeID'
	hh.PutBytes(c.CommitteeID[:])

	// Field (4) 'OperatorIDs'
	{
		if size := len(c.OperatorIDs); size > 13 {
			err = ssz.ErrListTooBigFn("CommitteeDutyTrace.OperatorIDs", size, 13)
			return
		}
		subIndx := hh.Index()
		for _, i := range c.OperatorIDs {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(c.OperatorIDs))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(13, numItems, 8))
	}

	// Field (5) 'AttestationDataRoot'
	hh.PutBytes(c.AttestationDataRoot[:])

	// Field (6) 'SyncCommitteeMessageRoot'
	hh.PutBytes(c.SyncCommitteeMessageRoot[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the CommitteeMessageTrace object
func (c *CommitteeMessageTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the CommitteeMessageTrace object to a target array
func (c *CommitteeMessageTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(1044)

	// Field (0) 'BeaconRoot'
	if size := len(c.BeaconRoot); size != 32 {
		err = ssz.ErrVectorLengthFn("CommitteeMessageTrace.BeaconRoot", size, 32)
		return
	}
	for ii := 0; ii < 32; ii++ {
		dst = append(dst, c.BeaconRoot[ii][:]...)
	}

	// Offset (1) 'Validators'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.Validators) * 8

	// Field (2) 'Signer'
	dst = ssz.MarshalUint64(dst, uint64(c.Signer))

	// Field (3) 'ReceivedTime'
	dst = ssz.MarshalUint64(dst, c.ReceivedTime)

	// Field (1) 'Validators'
	if size := len(c.Validators); size > 1500 {
		err = ssz.ErrListTooBigFn("CommitteeMessageTrace.Validators", size, 1500)
		return
	}
	for ii := 0; ii < len(c.Validators); ii++ {
		dst = ssz.MarshalUint64(dst, uint64(c.Validators[ii]))
	}

	return
}

// UnmarshalSSZ ssz unmarshals the CommitteeMessageTrace object
func (c *CommitteeMessageTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 1044 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'BeaconRoot'
	c.BeaconRoot = make([]phase0.Root, 32)
	for ii := 0; ii < 32; ii++ {
		copy(c.BeaconRoot[ii][:], buf[0:1024][ii*32:(ii+1)*32])
	}

	// Offset (1) 'Validators'
	if o1 = ssz.ReadOffset(buf[1024:1028]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 1044 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'Signer'
	c.Signer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[1028:1036]))

	// Field (3) 'ReceivedTime'
	c.ReceivedTime = ssz.UnmarshallUint64(buf[1036:1044])

	// Field (1) 'Validators'
	{
		buf = tail[o1:]
		num, err := ssz.DivideInt2(len(buf), 8, 1500)
		if err != nil {
			return err
		}
		c.Validators = make([]phase0.ValidatorIndex, num)
		for ii := 0; ii < num; ii++ {
			c.Validators[ii] = phase0.ValidatorIndex(ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8]))
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the CommitteeMessageTrace object
func (c *CommitteeMessageTrace) SizeSSZ() (size int) {
	size = 1044

	// Field (1) 'Validators'
	size += len(c.Validators) * 8

	return
}

// HashTreeRoot ssz hashes the CommitteeMessageTrace object
func (c *CommitteeMessageTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the CommitteeMessageTrace object with a hasher
func (c *CommitteeMessageTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'BeaconRoot'
	{
		if size := len(c.BeaconRoot); size != 32 {
			err = ssz.ErrVectorLengthFn("CommitteeMessageTrace.BeaconRoot", size, 32)
			return
		}
		subIndx := hh.Index()
		for _, i := range c.BeaconRoot {
			hh.Append(i[:])
		}
		hh.Merkleize(subIndx)
	}

	// Field (1) 'Validators'
	{
		if size := len(c.Validators); size > 1500 {
			err = ssz.ErrListTooBigFn("CommitteeMessageTrace.Validators", size, 1500)
			return
		}
		subIndx := hh.Index()
		for _, i := range c.Validators {
			hh.AppendUint64(uint64(i))
		}
		hh.FillUpTo32()
		numItems := uint64(len(c.Validators))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(1500, numItems, 8))
	}

	// Field (2) 'Signer'
	hh.PutUint64(uint64(c.Signer))

	// Field (3) 'ReceivedTime'
	hh.PutUint64(c.ReceivedTime)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the CommitteeMessageTrace object
func (c *CommitteeMessageTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the RoundTrace object
func (r *RoundTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(r)
}

// MarshalSSZTo ssz marshals the RoundTrace object to a target array
func (r *RoundTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(60)

	// Field (0) 'Proposer'
	dst = ssz.MarshalUint64(dst, uint64(r.Proposer))

	// Field (1) 'ProposalRoot'
	dst = append(dst, r.ProposalRoot[:]...)

	// Field (2) 'ProposalReceivedTime'
	dst = ssz.MarshalUint64(dst, r.ProposalReceivedTime)

	// Offset (3) 'Prepares'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(r.Prepares) * 56

	// Offset (4) 'Commits'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(r.Commits) * 56

	// Offset (5) 'RoundChanges'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(r.RoundChanges); ii++ {
		offset += 4
		offset += r.RoundChanges[ii].SizeSSZ()
	}

	// Field (3) 'Prepares'
	if size := len(r.Prepares); size > 13 {
		err = ssz.ErrListTooBigFn("RoundTrace.Prepares", size, 13)
		return
	}
	for ii := 0; ii < len(r.Prepares); ii++ {
		if dst, err = r.Prepares[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (4) 'Commits'
	if size := len(r.Commits); size > 13 {
		err = ssz.ErrListTooBigFn("RoundTrace.Commits", size, 13)
		return
	}
	for ii := 0; ii < len(r.Commits); ii++ {
		if dst, err = r.Commits[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (5) 'RoundChanges'
	if size := len(r.RoundChanges); size > 13 {
		err = ssz.ErrListTooBigFn("RoundTrace.RoundChanges", size, 13)
		return
	}
	{
		offset = 4 * len(r.RoundChanges)
		for ii := 0; ii < len(r.RoundChanges); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += r.RoundChanges[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(r.RoundChanges); ii++ {
		if dst, err = r.RoundChanges[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the RoundTrace object
func (r *RoundTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 60 {
		return ssz.ErrSize
	}

	tail := buf
	var o3, o4, o5 uint64

	// Field (0) 'Proposer'
	r.Proposer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[0:8]))

	// Field (1) 'ProposalRoot'
	copy(r.ProposalRoot[:], buf[8:40])

	// Field (2) 'ProposalReceivedTime'
	r.ProposalReceivedTime = ssz.UnmarshallUint64(buf[40:48])

	// Offset (3) 'Prepares'
	if o3 = ssz.ReadOffset(buf[48:52]); o3 > size {
		return ssz.ErrOffset
	}

	if o3 < 60 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (4) 'Commits'
	if o4 = ssz.ReadOffset(buf[52:56]); o4 > size || o3 > o4 {
		return ssz.ErrOffset
	}

	// Offset (5) 'RoundChanges'
	if o5 = ssz.ReadOffset(buf[56:60]); o5 > size || o4 > o5 {
		return ssz.ErrOffset
	}

	// Field (3) 'Prepares'
	{
		buf = tail[o3:o4]
		num, err := ssz.DivideInt2(len(buf), 56, 13)
		if err != nil {
			return err
		}
		r.Prepares = make([]*MessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if r.Prepares[ii] == nil {
				r.Prepares[ii] = new(MessageTrace)
			}
			if err = r.Prepares[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}

	// Field (4) 'Commits'
	{
		buf = tail[o4:o5]
		num, err := ssz.DivideInt2(len(buf), 56, 13)
		if err != nil {
			return err
		}
		r.Commits = make([]*MessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if r.Commits[ii] == nil {
				r.Commits[ii] = new(MessageTrace)
			}
			if err = r.Commits[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}

	// Field (5) 'RoundChanges'
	{
		buf = tail[o5:]
		num, err := ssz.DecodeDynamicLength(buf, 13)
		if err != nil {
			return err
		}
		r.RoundChanges = make([]*RoundChangeTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if err = r.RoundChanges[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the RoundTrace object
func (r *RoundTrace) SizeSSZ() (size int) {
	size = 60

	// Field (3) 'Prepares'
	size += len(r.Prepares) * 56

	// Field (4) 'Commits'
	size += len(r.Commits) * 56

	// Field (5) 'RoundChanges'
	for ii := 0; ii < len(r.RoundChanges); ii++ {
		size += 4
		size += r.RoundChanges[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the RoundTrace object
func (r *RoundTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(r)
}

// HashTreeRootWith ssz hashes the RoundTrace object with a hasher
func (r *RoundTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Proposer'
	hh.PutUint64(uint64(r.Proposer))

	// Field (1) 'ProposalRoot'
	hh.PutBytes(r.ProposalRoot[:])

	// Field (2) 'ProposalReceivedTime'
	hh.PutUint64(r.ProposalReceivedTime)

	// Field (3) 'Prepares'
	{
		subIndx := hh.Index()
		num := uint64(len(r.Prepares))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range r.Prepares {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (4) 'Commits'
	{
		subIndx := hh.Index()
		num := uint64(len(r.Commits))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range r.Commits {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (5) 'RoundChanges'
	{
		subIndx := hh.Index()
		num := uint64(len(r.RoundChanges))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range r.RoundChanges {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the RoundTrace object
func (r *RoundTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(r)
}

// MarshalSSZ ssz marshals the RoundChangeTrace object
func (r *RoundChangeTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(r)
}

// MarshalSSZTo ssz marshals the RoundChangeTrace object to a target array
func (r *RoundChangeTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(60)

	// Field (0) 'BeaconRoot'
	dst = append(dst, r.BeaconRoot[:]...)

	// Field (1) 'Signer'
	dst = ssz.MarshalUint64(dst, uint64(r.Signer))

	// Field (2) 'Validator'
	dst = ssz.MarshalUint64(dst, uint64(r.Validator))

	// Field (3) 'ReceivedTime'
	dst = ssz.MarshalUint64(dst, r.ReceivedTime)

	// Offset (4) 'PrepareMessages'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(r.PrepareMessages) * 56

	// Field (4) 'PrepareMessages'
	if size := len(r.PrepareMessages); size > 32 {
		err = ssz.ErrListTooBigFn("RoundChangeTrace.PrepareMessages", size, 32)
		return
	}
	for ii := 0; ii < len(r.PrepareMessages); ii++ {
		if dst, err = r.PrepareMessages[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the RoundChangeTrace object
func (r *RoundChangeTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 60 {
		return ssz.ErrSize
	}

	tail := buf
	var o4 uint64

	// Field (0) 'BeaconRoot'
	copy(r.BeaconRoot[:], buf[0:32])

	// Field (1) 'Signer'
	r.Signer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[32:40]))

	// Field (2) 'Validator'
	r.Validator = phase0.ValidatorIndex(ssz.UnmarshallUint64(buf[40:48]))

	// Field (3) 'ReceivedTime'
	r.ReceivedTime = ssz.UnmarshallUint64(buf[48:56])

	// Offset (4) 'PrepareMessages'
	if o4 = ssz.ReadOffset(buf[56:60]); o4 > size {
		return ssz.ErrOffset
	}

	if o4 < 60 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (4) 'PrepareMessages'
	{
		buf = tail[o4:]
		num, err := ssz.DivideInt2(len(buf), 56, 32)
		if err != nil {
			return err
		}
		r.PrepareMessages = make([]*MessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if r.PrepareMessages[ii] == nil {
				r.PrepareMessages[ii] = new(MessageTrace)
			}
			if err = r.PrepareMessages[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the RoundChangeTrace object
func (r *RoundChangeTrace) SizeSSZ() (size int) {
	size = 60

	// Field (4) 'PrepareMessages'
	size += len(r.PrepareMessages) * 56

	return
}

// HashTreeRoot ssz hashes the RoundChangeTrace object
func (r *RoundChangeTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(r)
}

// HashTreeRootWith ssz hashes the RoundChangeTrace object with a hasher
func (r *RoundChangeTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'BeaconRoot'
	hh.PutBytes(r.BeaconRoot[:])

	// Field (1) 'Signer'
	hh.PutUint64(uint64(r.Signer))

	// Field (2) 'Validator'
	hh.PutUint64(uint64(r.Validator))

	// Field (3) 'ReceivedTime'
	hh.PutUint64(r.ReceivedTime)

	// Field (4) 'PrepareMessages'
	{
		subIndx := hh.Index()
		num := uint64(len(r.PrepareMessages))
		if num > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range r.PrepareMessages {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the RoundChangeTrace object
func (r *RoundChangeTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(r)
}

// MarshalSSZ ssz marshals the MessageTrace object
func (m *MessageTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(m)
}

// MarshalSSZTo ssz marshals the MessageTrace object to a target array
func (m *MessageTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'BeaconRoot'
	dst = append(dst, m.BeaconRoot[:]...)

	// Field (1) 'Signer'
	dst = ssz.MarshalUint64(dst, uint64(m.Signer))

	// Field (2) 'Validator'
	dst = ssz.MarshalUint64(dst, uint64(m.Validator))

	// Field (3) 'ReceivedTime'
	dst = ssz.MarshalUint64(dst, m.ReceivedTime)

	return
}

// UnmarshalSSZ ssz unmarshals the MessageTrace object
func (m *MessageTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 56 {
		return ssz.ErrSize
	}

	// Field (0) 'BeaconRoot'
	copy(m.BeaconRoot[:], buf[0:32])

	// Field (1) 'Signer'
	m.Signer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[32:40]))

	// Field (2) 'Validator'
	m.Validator = phase0.ValidatorIndex(ssz.UnmarshallUint64(buf[40:48]))

	// Field (3) 'ReceivedTime'
	m.ReceivedTime = ssz.UnmarshallUint64(buf[48:56])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the MessageTrace object
func (m *MessageTrace) SizeSSZ() (size int) {
	size = 56
	return
}

// HashTreeRoot ssz hashes the MessageTrace object
func (m *MessageTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(m)
}

// HashTreeRootWith ssz hashes the MessageTrace object with a hasher
func (m *MessageTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'BeaconRoot'
	hh.PutBytes(m.BeaconRoot[:])

	// Field (1) 'Signer'
	hh.PutUint64(uint64(m.Signer))

	// Field (2) 'Validator'
	hh.PutUint64(uint64(m.Validator))

	// Field (3) 'ReceivedTime'
	hh.PutUint64(m.ReceivedTime)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the MessageTrace object
func (m *MessageTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(m)
}
