// Code generated by fastssz. DO NOT EDIT.
// Hash: cb7b038f485e6b710677a90cbbffa048fdbf8636e81ea388baaec2c10015b9da
// Version: 0.1.3
package exporter

import (
	"github.com/attestantio/go-eth2-client/spec/phase0"
	ssz "github.com/ferranbt/fastssz"
	spectypes "github.com/ssvlabs/ssv-spec/types"
)

// MarshalSSZ ssz marshals the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the ValidatorDutyTrace object to a target array
func (v *ValidatorDutyTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(36)

	// Field (0) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(v.Slot))

	// Offset (1) 'Pre'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(v.Pre) * 56

	// Offset (2) 'Rounds'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(v.Rounds); ii++ {
		offset += 4
		offset += v.Rounds[ii].SizeSSZ()
	}

	// Offset (3) 'Post'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(v.Post) * 56

	// Field (4) 'Role'
	dst = ssz.MarshalUint64(dst, uint64(v.Role))

	// Field (5) 'Validator'
	dst = ssz.MarshalUint64(dst, uint64(v.Validator))

	// Field (1) 'Pre'
	if size := len(v.Pre); size > 4 {
		err = ssz.ErrListTooBigFn("ValidatorDutyTrace.Pre", size, 4)
		return
	}
	for ii := 0; ii < len(v.Pre); ii++ {
		if dst, err = v.Pre[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (2) 'Rounds'
	if size := len(v.Rounds); size > 4 {
		err = ssz.ErrListTooBigFn("ValidatorDutyTrace.Rounds", size, 4)
		return
	}
	{
		offset = 4 * len(v.Rounds)
		for ii := 0; ii < len(v.Rounds); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += v.Rounds[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(v.Rounds); ii++ {
		if dst, err = v.Rounds[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (3) 'Post'
	if size := len(v.Post); size > 4 {
		err = ssz.ErrListTooBigFn("ValidatorDutyTrace.Post", size, 4)
		return
	}
	for ii := 0; ii < len(v.Post); ii++ {
		if dst, err = v.Post[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 36 {
		return ssz.ErrSize
	}

	tail := buf
	var o1, o2, o3 uint64

	// Field (0) 'Slot'
	v.Slot = phase0.Slot(ssz.UnmarshallUint64(buf[0:8]))

	// Offset (1) 'Pre'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 36 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (2) 'Rounds'
	if o2 = ssz.ReadOffset(buf[12:16]); o2 > size || o1 > o2 {
		return ssz.ErrOffset
	}

	// Offset (3) 'Post'
	if o3 = ssz.ReadOffset(buf[16:20]); o3 > size || o2 > o3 {
		return ssz.ErrOffset
	}

	// Field (4) 'Role'
	v.Role = spectypes.BeaconRole(ssz.UnmarshallUint64(buf[20:28]))

	// Field (5) 'Validator'
	v.Validator = phase0.ValidatorIndex(ssz.UnmarshallUint64(buf[28:36]))

	// Field (1) 'Pre'
	{
		buf = tail[o1:o2]
		num, err := ssz.DivideInt2(len(buf), 56, 4)
		if err != nil {
			return err
		}
		v.Pre = make([]*MessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if v.Pre[ii] == nil {
				v.Pre[ii] = new(MessageTrace)
			}
			if err = v.Pre[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}

	// Field (2) 'Rounds'
	{
		buf = tail[o2:o3]
		num, err := ssz.DecodeDynamicLength(buf, 4)
		if err != nil {
			return err
		}
		v.Rounds = make([]*RoundTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if v.Rounds[indx] == nil {
				v.Rounds[indx] = new(RoundTrace)
			}
			if err = v.Rounds[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (3) 'Post'
	{
		buf = tail[o3:]
		num, err := ssz.DivideInt2(len(buf), 56, 4)
		if err != nil {
			return err
		}
		v.Post = make([]*MessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if v.Post[ii] == nil {
				v.Post[ii] = new(MessageTrace)
			}
			if err = v.Post[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) SizeSSZ() (size int) {
	size = 36

	// Field (1) 'Pre'
	size += len(v.Pre) * 56

	// Field (2) 'Rounds'
	for ii := 0; ii < len(v.Rounds); ii++ {
		size += 4
		size += v.Rounds[ii].SizeSSZ()
	}

	// Field (3) 'Post'
	size += len(v.Post) * 56

	return
}

// HashTreeRoot ssz hashes the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the ValidatorDutyTrace object with a hasher
func (v *ValidatorDutyTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(v.Slot))

	// Field (1) 'Pre'
	{
		subIndx := hh.Index()
		num := uint64(len(v.Pre))
		if num > 4 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range v.Pre {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4)
	}

	// Field (2) 'Rounds'
	{
		subIndx := hh.Index()
		num := uint64(len(v.Rounds))
		if num > 4 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range v.Rounds {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4)
	}

	// Field (3) 'Post'
	{
		subIndx := hh.Index()
		num := uint64(len(v.Post))
		if num > 4 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range v.Post {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4)
	}

	// Field (4) 'Role'
	hh.PutUint64(uint64(v.Role))

	// Field (5) 'Validator'
	hh.PutUint64(uint64(v.Validator))

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(v)
}

// MarshalSSZ ssz marshals the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the CommitteeDutyTrace object to a target array
func (c *CommitteeDutyTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(120)

	// Field (0) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(c.Slot))

	// Offset (1) 'Pre'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.Pre) * 56

	// Offset (2) 'Rounds'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(c.Rounds); ii++ {
		offset += 4
		offset += c.Rounds[ii].SizeSSZ()
	}

	// Offset (3) 'Post'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.Post) * 56

	// Field (4) 'CommitteeID'
	dst = append(dst, c.CommitteeID[:]...)

	// Offset (5) 'OperatorIDs'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.OperatorIDs) * 8

	// Field (6) 'AttestationDataRoot'
	dst = append(dst, c.AttestationDataRoot[:]...)

	// Field (7) 'SyncCommitteeMessageRoot'
	dst = append(dst, c.SyncCommitteeMessageRoot[:]...)

	// Field (1) 'Pre'
	if size := len(c.Pre); size > 4 {
		err = ssz.ErrListTooBigFn("CommitteeDutyTrace.Pre", size, 4)
		return
	}
	for ii := 0; ii < len(c.Pre); ii++ {
		if dst, err = c.Pre[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (2) 'Rounds'
	if size := len(c.Rounds); size > 4 {
		err = ssz.ErrListTooBigFn("CommitteeDutyTrace.Rounds", size, 4)
		return
	}
	{
		offset = 4 * len(c.Rounds)
		for ii := 0; ii < len(c.Rounds); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += c.Rounds[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(c.Rounds); ii++ {
		if dst, err = c.Rounds[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (3) 'Post'
	if size := len(c.Post); size > 4 {
		err = ssz.ErrListTooBigFn("CommitteeDutyTrace.Post", size, 4)
		return
	}
	for ii := 0; ii < len(c.Post); ii++ {
		if dst, err = c.Post[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (5) 'OperatorIDs'
	if size := len(c.OperatorIDs); size > 4 {
		err = ssz.ErrListTooBigFn("CommitteeDutyTrace.OperatorIDs", size, 4)
		return
	}
	for ii := 0; ii < len(c.OperatorIDs); ii++ {
		dst = ssz.MarshalUint64(dst, uint64(c.OperatorIDs[ii]))
	}

	return
}

// UnmarshalSSZ ssz unmarshals the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 120 {
		return ssz.ErrSize
	}

	tail := buf
	var o1, o2, o3, o5 uint64

	// Field (0) 'Slot'
	c.Slot = phase0.Slot(ssz.UnmarshallUint64(buf[0:8]))

	// Offset (1) 'Pre'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 120 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (2) 'Rounds'
	if o2 = ssz.ReadOffset(buf[12:16]); o2 > size || o1 > o2 {
		return ssz.ErrOffset
	}

	// Offset (3) 'Post'
	if o3 = ssz.ReadOffset(buf[16:20]); o3 > size || o2 > o3 {
		return ssz.ErrOffset
	}

	// Field (4) 'CommitteeID'
	copy(c.CommitteeID[:], buf[20:52])

	// Offset (5) 'OperatorIDs'
	if o5 = ssz.ReadOffset(buf[52:56]); o5 > size || o3 > o5 {
		return ssz.ErrOffset
	}

	// Field (6) 'AttestationDataRoot'
	copy(c.AttestationDataRoot[:], buf[56:88])

	// Field (7) 'SyncCommitteeMessageRoot'
	copy(c.SyncCommitteeMessageRoot[:], buf[88:120])

	// Field (1) 'Pre'
	{
		buf = tail[o1:o2]
		num, err := ssz.DivideInt2(len(buf), 56, 4)
		if err != nil {
			return err
		}
		c.Pre = make([]*MessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if c.Pre[ii] == nil {
				c.Pre[ii] = new(MessageTrace)
			}
			if err = c.Pre[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}

	// Field (2) 'Rounds'
	{
		buf = tail[o2:o3]
		num, err := ssz.DecodeDynamicLength(buf, 4)
		if err != nil {
			return err
		}
		c.Rounds = make([]*RoundTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if c.Rounds[indx] == nil {
				c.Rounds[indx] = new(RoundTrace)
			}
			if err = c.Rounds[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (3) 'Post'
	{
		buf = tail[o3:o5]
		num, err := ssz.DivideInt2(len(buf), 56, 4)
		if err != nil {
			return err
		}
		c.Post = make([]*MessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if c.Post[ii] == nil {
				c.Post[ii] = new(MessageTrace)
			}
			if err = c.Post[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}

	// Field (5) 'OperatorIDs'
	{
		buf = tail[o5:]
		num, err := ssz.DivideInt2(len(buf), 8, 4)
		if err != nil {
			return err
		}
		c.OperatorIDs = ssz.ExtendUint64(c.OperatorIDs, num)
		for ii := 0; ii < num; ii++ {
			c.OperatorIDs[ii] = spectypes.OperatorID(ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8]))
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) SizeSSZ() (size int) {
	size = 120

	// Field (1) 'Pre'
	size += len(c.Pre) * 56

	// Field (2) 'Rounds'
	for ii := 0; ii < len(c.Rounds); ii++ {
		size += 4
		size += c.Rounds[ii].SizeSSZ()
	}

	// Field (3) 'Post'
	size += len(c.Post) * 56

	// Field (5) 'OperatorIDs'
	size += len(c.OperatorIDs) * 8

	return
}

// HashTreeRoot ssz hashes the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the CommitteeDutyTrace object with a hasher
func (c *CommitteeDutyTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(c.Slot))

	// Field (1) 'Pre'
	{
		subIndx := hh.Index()
		num := uint64(len(c.Pre))
		if num > 4 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range c.Pre {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4)
	}

	// Field (2) 'Rounds'
	{
		subIndx := hh.Index()
		num := uint64(len(c.Rounds))
		if num > 4 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range c.Rounds {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4)
	}

	// Field (3) 'Post'
	{
		subIndx := hh.Index()
		num := uint64(len(c.Post))
		if num > 4 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range c.Post {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4)
	}

	// Field (4) 'CommitteeID'
	hh.PutBytes(c.CommitteeID[:])

	// Field (5) 'OperatorIDs'
	{
		if size := len(c.OperatorIDs); size > 4 {
			err = ssz.ErrListTooBigFn("CommitteeDutyTrace.OperatorIDs", size, 4)
			return
		}
		subIndx := hh.Index()
		for _, i := range c.OperatorIDs {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(c.OperatorIDs))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(4, numItems, 8))
	}

	// Field (6) 'AttestationDataRoot'
	hh.PutBytes(c.AttestationDataRoot[:])

	// Field (7) 'SyncCommitteeMessageRoot'
	hh.PutBytes(c.SyncCommitteeMessageRoot[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the RoundTrace object
func (r *RoundTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(r)
}

// MarshalSSZTo ssz marshals the RoundTrace object to a target array
func (r *RoundTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(48)

	// Field (0) 'ProposalRoot'
	dst = append(dst, r.ProposalRoot[:]...)

	// Field (1) 'ProposalReceived'
	dst = ssz.MarshalUint64(dst, r.ProposalReceived)

	// Offset (2) 'Prepares'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(r.Prepares) * 56

	// Offset (3) 'Commits'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(r.Commits) * 56

	// Field (2) 'Prepares'
	if size := len(r.Prepares); size > 4 {
		err = ssz.ErrListTooBigFn("RoundTrace.Prepares", size, 4)
		return
	}
	for ii := 0; ii < len(r.Prepares); ii++ {
		if dst, err = r.Prepares[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (3) 'Commits'
	if size := len(r.Commits); size > 4 {
		err = ssz.ErrListTooBigFn("RoundTrace.Commits", size, 4)
		return
	}
	for ii := 0; ii < len(r.Commits); ii++ {
		if dst, err = r.Commits[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the RoundTrace object
func (r *RoundTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 48 {
		return ssz.ErrSize
	}

	tail := buf
	var o2, o3 uint64

	// Field (0) 'ProposalRoot'
	copy(r.ProposalRoot[:], buf[0:32])

	// Field (1) 'ProposalReceived'
	r.ProposalReceived = ssz.UnmarshallUint64(buf[32:40])

	// Offset (2) 'Prepares'
	if o2 = ssz.ReadOffset(buf[40:44]); o2 > size {
		return ssz.ErrOffset
	}

	if o2 < 48 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (3) 'Commits'
	if o3 = ssz.ReadOffset(buf[44:48]); o3 > size || o2 > o3 {
		return ssz.ErrOffset
	}

	// Field (2) 'Prepares'
	{
		buf = tail[o2:o3]
		num, err := ssz.DivideInt2(len(buf), 56, 4)
		if err != nil {
			return err
		}
		r.Prepares = make([]*MessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if r.Prepares[ii] == nil {
				r.Prepares[ii] = new(MessageTrace)
			}
			if err = r.Prepares[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}

	// Field (3) 'Commits'
	{
		buf = tail[o3:]
		num, err := ssz.DivideInt2(len(buf), 56, 4)
		if err != nil {
			return err
		}
		r.Commits = make([]*MessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if r.Commits[ii] == nil {
				r.Commits[ii] = new(MessageTrace)
			}
			if err = r.Commits[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the RoundTrace object
func (r *RoundTrace) SizeSSZ() (size int) {
	size = 48

	// Field (2) 'Prepares'
	size += len(r.Prepares) * 56

	// Field (3) 'Commits'
	size += len(r.Commits) * 56

	return
}

// HashTreeRoot ssz hashes the RoundTrace object
func (r *RoundTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(r)
}

// HashTreeRootWith ssz hashes the RoundTrace object with a hasher
func (r *RoundTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ProposalRoot'
	hh.PutBytes(r.ProposalRoot[:])

	// Field (1) 'ProposalReceived'
	hh.PutUint64(r.ProposalReceived)

	// Field (2) 'Prepares'
	{
		subIndx := hh.Index()
		num := uint64(len(r.Prepares))
		if num > 4 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range r.Prepares {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4)
	}

	// Field (3) 'Commits'
	{
		subIndx := hh.Index()
		num := uint64(len(r.Commits))
		if num > 4 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range r.Commits {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the RoundTrace object
func (r *RoundTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(r)
}

// MarshalSSZ ssz marshals the MessageTrace object
func (m *MessageTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(m)
}

// MarshalSSZTo ssz marshals the MessageTrace object to a target array
func (m *MessageTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'BeaconRoot'
	dst = append(dst, m.BeaconRoot[:]...)

	// Field (1) 'Signer'
	dst = ssz.MarshalUint64(dst, uint64(m.Signer))

	// Field (2) 'Validator'
	dst = ssz.MarshalUint64(dst, uint64(m.Validator))

	// Field (3) 'Received'
	dst = ssz.MarshalUint64(dst, m.Received)

	return
}

// UnmarshalSSZ ssz unmarshals the MessageTrace object
func (m *MessageTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 56 {
		return ssz.ErrSize
	}

	// Field (0) 'BeaconRoot'
	copy(m.BeaconRoot[:], buf[0:32])

	// Field (1) 'Signer'
	m.Signer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[32:40]))

	// Field (2) 'Validator'
	m.Validator = phase0.ValidatorIndex(ssz.UnmarshallUint64(buf[40:48]))

	// Field (3) 'Received'
	m.Received = ssz.UnmarshallUint64(buf[48:56])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the MessageTrace object
func (m *MessageTrace) SizeSSZ() (size int) {
	size = 56
	return
}

// HashTreeRoot ssz hashes the MessageTrace object
func (m *MessageTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(m)
}

// HashTreeRootWith ssz hashes the MessageTrace object with a hasher
func (m *MessageTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'BeaconRoot'
	hh.PutBytes(m.BeaconRoot[:])

	// Field (1) 'Signer'
	hh.PutUint64(uint64(m.Signer))

	// Field (2) 'Validator'
	hh.PutUint64(uint64(m.Validator))

	// Field (3) 'Received'
	hh.PutUint64(m.Received)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the MessageTrace object
func (m *MessageTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(m)
}
