// Code generated by fastssz. DO NOT EDIT.
// Hash: 02e1063c48ea6cbe2c9f3645e11f00a9b7dfea58e6f937545867db8fd98a39dc
// Version: 0.1.3
package exporter

import (
	"github.com/attestantio/go-eth2-client/spec/phase0"
	ssz "github.com/ferranbt/fastssz"
	spectypes "github.com/ssvlabs/ssv-spec/types"
)

// MarshalSSZ ssz marshals the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the ValidatorDutyTrace object to a target array
func (v *ValidatorDutyTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(40)

	// Offset (0) 'Rounds'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(v.Rounds); ii++ {
		offset += 4
		offset += v.Rounds[ii].SizeSSZ()
	}

	// Offset (1) 'Decideds'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(v.Decideds); ii++ {
		offset += 4
		offset += v.Decideds[ii].SizeSSZ()
	}

	// Field (2) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(v.Slot))

	// Offset (3) 'Pre'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(v.Pre) * 56

	// Offset (4) 'Post'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(v.Post) * 56

	// Field (5) 'Role'
	dst = ssz.MarshalUint64(dst, uint64(v.Role))

	// Field (6) 'Validator'
	dst = ssz.MarshalUint64(dst, uint64(v.Validator))

	// Field (0) 'Rounds'
	if size := len(v.Rounds); size > 15 {
		err = ssz.ErrListTooBigFn("ValidatorDutyTrace.Rounds", size, 15)
		return
	}
	{
		offset = 4 * len(v.Rounds)
		for ii := 0; ii < len(v.Rounds); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += v.Rounds[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(v.Rounds); ii++ {
		if dst, err = v.Rounds[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (1) 'Decideds'
	if size := len(v.Decideds); size > 256 {
		err = ssz.ErrListTooBigFn("ValidatorDutyTrace.Decideds", size, 256)
		return
	}
	{
		offset = 4 * len(v.Decideds)
		for ii := 0; ii < len(v.Decideds); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += v.Decideds[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(v.Decideds); ii++ {
		if dst, err = v.Decideds[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (3) 'Pre'
	if size := len(v.Pre); size > 13 {
		err = ssz.ErrListTooBigFn("ValidatorDutyTrace.Pre", size, 13)
		return
	}
	for ii := 0; ii < len(v.Pre); ii++ {
		if dst, err = v.Pre[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (4) 'Post'
	if size := len(v.Post); size > 13 {
		err = ssz.ErrListTooBigFn("ValidatorDutyTrace.Post", size, 13)
		return
	}
	for ii := 0; ii < len(v.Post); ii++ {
		if dst, err = v.Post[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 40 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1, o3, o4 uint64

	// Offset (0) 'Rounds'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 40 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (1) 'Decideds'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (2) 'Slot'
	v.Slot = phase0.Slot(ssz.UnmarshallUint64(buf[8:16]))

	// Offset (3) 'Pre'
	if o3 = ssz.ReadOffset(buf[16:20]); o3 > size || o1 > o3 {
		return ssz.ErrOffset
	}

	// Offset (4) 'Post'
	if o4 = ssz.ReadOffset(buf[20:24]); o4 > size || o3 > o4 {
		return ssz.ErrOffset
	}

	// Field (5) 'Role'
	v.Role = spectypes.BeaconRole(ssz.UnmarshallUint64(buf[24:32]))

	// Field (6) 'Validator'
	v.Validator = phase0.ValidatorIndex(ssz.UnmarshallUint64(buf[32:40]))

	// Field (0) 'Rounds'
	{
		buf = tail[o0:o1]
		num, err := ssz.DecodeDynamicLength(buf, 15)
		if err != nil {
			return err
		}
		v.Rounds = make([]*RoundTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if v.Rounds[indx] == nil {
				v.Rounds[indx] = new(RoundTrace)
			}
			if err = v.Rounds[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (1) 'Decideds'
	{
		buf = tail[o1:o3]
		num, err := ssz.DecodeDynamicLength(buf, 256)
		if err != nil {
			return err
		}
		v.Decideds = make([]*DecidedTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if v.Decideds[indx] == nil {
				v.Decideds[indx] = new(DecidedTrace)
			}
			if err = v.Decideds[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (3) 'Pre'
	{
		buf = tail[o3:o4]
		num, err := ssz.DivideInt2(len(buf), 56, 13)
		if err != nil {
			return err
		}
		v.Pre = make([]*PartialSigMessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if v.Pre[ii] == nil {
				v.Pre[ii] = new(PartialSigMessageTrace)
			}
			if err = v.Pre[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}

	// Field (4) 'Post'
	{
		buf = tail[o4:]
		num, err := ssz.DivideInt2(len(buf), 56, 13)
		if err != nil {
			return err
		}
		v.Post = make([]*PartialSigMessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if v.Post[ii] == nil {
				v.Post[ii] = new(PartialSigMessageTrace)
			}
			if err = v.Post[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) SizeSSZ() (size int) {
	size = 40

	// Field (0) 'Rounds'
	for ii := 0; ii < len(v.Rounds); ii++ {
		size += 4
		size += v.Rounds[ii].SizeSSZ()
	}

	// Field (1) 'Decideds'
	for ii := 0; ii < len(v.Decideds); ii++ {
		size += 4
		size += v.Decideds[ii].SizeSSZ()
	}

	// Field (3) 'Pre'
	size += len(v.Pre) * 56

	// Field (4) 'Post'
	size += len(v.Post) * 56

	return
}

// HashTreeRoot ssz hashes the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the ValidatorDutyTrace object with a hasher
func (v *ValidatorDutyTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Rounds'
	{
		subIndx := hh.Index()
		num := uint64(len(v.Rounds))
		if num > 15 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range v.Rounds {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 15)
	}

	// Field (1) 'Decideds'
	{
		subIndx := hh.Index()
		num := uint64(len(v.Decideds))
		if num > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range v.Decideds {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 256)
	}

	// Field (2) 'Slot'
	hh.PutUint64(uint64(v.Slot))

	// Field (3) 'Pre'
	{
		subIndx := hh.Index()
		num := uint64(len(v.Pre))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range v.Pre {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (4) 'Post'
	{
		subIndx := hh.Index()
		num := uint64(len(v.Post))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range v.Post {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (5) 'Role'
	hh.PutUint64(uint64(v.Role))

	// Field (6) 'Validator'
	hh.PutUint64(uint64(v.Validator))

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(v)
}

// MarshalSSZ ssz marshals the DecidedTrace object
func (d *DecidedTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(d)
}

// MarshalSSZTo ssz marshals the DecidedTrace object to a target array
func (d *DecidedTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(60)

	// Field (0) 'Round'
	dst = ssz.MarshalUint64(dst, d.Round)

	// Field (1) 'BeaconRoot'
	dst = append(dst, d.BeaconRoot[:]...)

	// Field (2) 'Signer'
	dst = ssz.MarshalUint64(dst, uint64(d.Signer))

	// Field (3) 'ReceivedTime'
	dst = ssz.MarshalTime(dst, d.ReceivedTime)

	// Offset (4) 'Signers'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(d.Signers) * 8

	// Field (4) 'Signers'
	if size := len(d.Signers); size > 13 {
		err = ssz.ErrListTooBigFn("DecidedTrace.Signers", size, 13)
		return
	}
	for ii := 0; ii < len(d.Signers); ii++ {
		dst = ssz.MarshalUint64(dst, uint64(d.Signers[ii]))
	}

	return
}

// UnmarshalSSZ ssz unmarshals the DecidedTrace object
func (d *DecidedTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 60 {
		return ssz.ErrSize
	}

	tail := buf
	var o4 uint64

	// Field (0) 'Round'
	d.Round = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'BeaconRoot'
	copy(d.BeaconRoot[:], buf[8:40])

	// Field (2) 'Signer'
	d.Signer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[40:48]))

	// Field (3) 'ReceivedTime'
	d.ReceivedTime = ssz.UnmarshalTime(buf[48:56])

	// Offset (4) 'Signers'
	if o4 = ssz.ReadOffset(buf[56:60]); o4 > size {
		return ssz.ErrOffset
	}

	if o4 < 60 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (4) 'Signers'
	{
		buf = tail[o4:]
		num, err := ssz.DivideInt2(len(buf), 8, 13)
		if err != nil {
			return err
		}
		d.Signers = ssz.ExtendUint64(d.Signers, num)
		for ii := 0; ii < num; ii++ {
			d.Signers[ii] = spectypes.OperatorID(ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8]))
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the DecidedTrace object
func (d *DecidedTrace) SizeSSZ() (size int) {
	size = 60

	// Field (4) 'Signers'
	size += len(d.Signers) * 8

	return
}

// HashTreeRoot ssz hashes the DecidedTrace object
func (d *DecidedTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(d)
}

// HashTreeRootWith ssz hashes the DecidedTrace object with a hasher
func (d *DecidedTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Round'
	hh.PutUint64(d.Round)

	// Field (1) 'BeaconRoot'
	hh.PutBytes(d.BeaconRoot[:])

	// Field (2) 'Signer'
	hh.PutUint64(uint64(d.Signer))

	// Field (3) 'ReceivedTime'
	hh.PutUint64(uint64(d.ReceivedTime.Unix()))

	// Field (4) 'Signers'
	{
		if size := len(d.Signers); size > 13 {
			err = ssz.ErrListTooBigFn("DecidedTrace.Signers", size, 13)
			return
		}
		subIndx := hh.Index()
		for _, i := range d.Signers {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(d.Signers))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(13, numItems, 8))
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the DecidedTrace object
func (d *DecidedTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(d)
}

// MarshalSSZ ssz marshals the RoundTrace object
func (r *RoundTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(r)
}

// MarshalSSZTo ssz marshals the RoundTrace object to a target array
func (r *RoundTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(24)

	// Field (0) 'Proposer'
	dst = ssz.MarshalUint64(dst, uint64(r.Proposer))

	// Offset (1) 'ProposalTrace'
	dst = ssz.WriteOffset(dst, offset)
	if r.ProposalTrace == nil {
		r.ProposalTrace = new(ProposalTrace)
	}
	offset += r.ProposalTrace.SizeSSZ()

	// Offset (2) 'Prepares'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(r.Prepares) * 56

	// Offset (3) 'Commits'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(r.Commits) * 56

	// Offset (4) 'RoundChanges'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(r.RoundChanges); ii++ {
		offset += 4
		offset += r.RoundChanges[ii].SizeSSZ()
	}

	// Field (1) 'ProposalTrace'
	if dst, err = r.ProposalTrace.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'Prepares'
	if size := len(r.Prepares); size > 13 {
		err = ssz.ErrListTooBigFn("RoundTrace.Prepares", size, 13)
		return
	}
	for ii := 0; ii < len(r.Prepares); ii++ {
		if dst, err = r.Prepares[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (3) 'Commits'
	if size := len(r.Commits); size > 13 {
		err = ssz.ErrListTooBigFn("RoundTrace.Commits", size, 13)
		return
	}
	for ii := 0; ii < len(r.Commits); ii++ {
		if dst, err = r.Commits[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (4) 'RoundChanges'
	if size := len(r.RoundChanges); size > 13 {
		err = ssz.ErrListTooBigFn("RoundTrace.RoundChanges", size, 13)
		return
	}
	{
		offset = 4 * len(r.RoundChanges)
		for ii := 0; ii < len(r.RoundChanges); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += r.RoundChanges[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(r.RoundChanges); ii++ {
		if dst, err = r.RoundChanges[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the RoundTrace object
func (r *RoundTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 24 {
		return ssz.ErrSize
	}

	tail := buf
	var o1, o2, o3, o4 uint64

	// Field (0) 'Proposer'
	r.Proposer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[0:8]))

	// Offset (1) 'ProposalTrace'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 24 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (2) 'Prepares'
	if o2 = ssz.ReadOffset(buf[12:16]); o2 > size || o1 > o2 {
		return ssz.ErrOffset
	}

	// Offset (3) 'Commits'
	if o3 = ssz.ReadOffset(buf[16:20]); o3 > size || o2 > o3 {
		return ssz.ErrOffset
	}

	// Offset (4) 'RoundChanges'
	if o4 = ssz.ReadOffset(buf[20:24]); o4 > size || o3 > o4 {
		return ssz.ErrOffset
	}

	// Field (1) 'ProposalTrace'
	{
		buf = tail[o1:o2]
		if r.ProposalTrace == nil {
			r.ProposalTrace = new(ProposalTrace)
		}
		if err = r.ProposalTrace.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (2) 'Prepares'
	{
		buf = tail[o2:o3]
		num, err := ssz.DivideInt2(len(buf), 56, 13)
		if err != nil {
			return err
		}
		r.Prepares = make([]*MessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if r.Prepares[ii] == nil {
				r.Prepares[ii] = new(MessageTrace)
			}
			if err = r.Prepares[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}

	// Field (3) 'Commits'
	{
		buf = tail[o3:o4]
		num, err := ssz.DivideInt2(len(buf), 56, 13)
		if err != nil {
			return err
		}
		r.Commits = make([]*MessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if r.Commits[ii] == nil {
				r.Commits[ii] = new(MessageTrace)
			}
			if err = r.Commits[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}

	// Field (4) 'RoundChanges'
	{
		buf = tail[o4:]
		num, err := ssz.DecodeDynamicLength(buf, 13)
		if err != nil {
			return err
		}
		r.RoundChanges = make([]*RoundChangeTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if r.RoundChanges[indx] == nil {
				r.RoundChanges[indx] = new(RoundChangeTrace)
			}
			if err = r.RoundChanges[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the RoundTrace object
func (r *RoundTrace) SizeSSZ() (size int) {
	size = 24

	// Field (1) 'ProposalTrace'
	if r.ProposalTrace == nil {
		r.ProposalTrace = new(ProposalTrace)
	}
	size += r.ProposalTrace.SizeSSZ()

	// Field (2) 'Prepares'
	size += len(r.Prepares) * 56

	// Field (3) 'Commits'
	size += len(r.Commits) * 56

	// Field (4) 'RoundChanges'
	for ii := 0; ii < len(r.RoundChanges); ii++ {
		size += 4
		size += r.RoundChanges[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the RoundTrace object
func (r *RoundTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(r)
}

// HashTreeRootWith ssz hashes the RoundTrace object with a hasher
func (r *RoundTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Proposer'
	hh.PutUint64(uint64(r.Proposer))

	// Field (1) 'ProposalTrace'
	if err = r.ProposalTrace.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'Prepares'
	{
		subIndx := hh.Index()
		num := uint64(len(r.Prepares))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range r.Prepares {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (3) 'Commits'
	{
		subIndx := hh.Index()
		num := uint64(len(r.Commits))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range r.Commits {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (4) 'RoundChanges'
	{
		subIndx := hh.Index()
		num := uint64(len(r.RoundChanges))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range r.RoundChanges {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the RoundTrace object
func (r *RoundTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(r)
}

// MarshalSSZ ssz marshals the RoundChangeTrace object
func (r *RoundChangeTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(r)
}

// MarshalSSZTo ssz marshals the RoundChangeTrace object to a target array
func (r *RoundChangeTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(68)

	// Field (0) 'Round'
	dst = ssz.MarshalUint64(dst, r.Round)

	// Field (1) 'BeaconRoot'
	dst = append(dst, r.BeaconRoot[:]...)

	// Field (2) 'Signer'
	dst = ssz.MarshalUint64(dst, uint64(r.Signer))

	// Field (3) 'ReceivedTime'
	dst = ssz.MarshalTime(dst, r.ReceivedTime)

	// Field (4) 'PreparedRound'
	dst = ssz.MarshalUint64(dst, r.PreparedRound)

	// Offset (5) 'PrepareMessages'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(r.PrepareMessages) * 56

	// Field (5) 'PrepareMessages'
	if size := len(r.PrepareMessages); size > 13 {
		err = ssz.ErrListTooBigFn("RoundChangeTrace.PrepareMessages", size, 13)
		return
	}
	for ii := 0; ii < len(r.PrepareMessages); ii++ {
		if dst, err = r.PrepareMessages[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the RoundChangeTrace object
func (r *RoundChangeTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 68 {
		return ssz.ErrSize
	}

	tail := buf
	var o5 uint64

	// Field (0) 'Round'
	r.Round = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'BeaconRoot'
	copy(r.BeaconRoot[:], buf[8:40])

	// Field (2) 'Signer'
	r.Signer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[40:48]))

	// Field (3) 'ReceivedTime'
	r.ReceivedTime = ssz.UnmarshalTime(buf[48:56])

	// Field (4) 'PreparedRound'
	r.PreparedRound = ssz.UnmarshallUint64(buf[56:64])

	// Offset (5) 'PrepareMessages'
	if o5 = ssz.ReadOffset(buf[64:68]); o5 > size {
		return ssz.ErrOffset
	}

	if o5 < 68 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (5) 'PrepareMessages'
	{
		buf = tail[o5:]
		num, err := ssz.DivideInt2(len(buf), 56, 13)
		if err != nil {
			return err
		}
		r.PrepareMessages = make([]*MessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if r.PrepareMessages[ii] == nil {
				r.PrepareMessages[ii] = new(MessageTrace)
			}
			if err = r.PrepareMessages[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the RoundChangeTrace object
func (r *RoundChangeTrace) SizeSSZ() (size int) {
	size = 68

	// Field (5) 'PrepareMessages'
	size += len(r.PrepareMessages) * 56

	return
}

// HashTreeRoot ssz hashes the RoundChangeTrace object
func (r *RoundChangeTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(r)
}

// HashTreeRootWith ssz hashes the RoundChangeTrace object with a hasher
func (r *RoundChangeTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Round'
	hh.PutUint64(r.Round)

	// Field (1) 'BeaconRoot'
	hh.PutBytes(r.BeaconRoot[:])

	// Field (2) 'Signer'
	hh.PutUint64(uint64(r.Signer))

	// Field (3) 'ReceivedTime'
	hh.PutUint64(uint64(r.ReceivedTime.Unix()))

	// Field (4) 'PreparedRound'
	hh.PutUint64(r.PreparedRound)

	// Field (5) 'PrepareMessages'
	{
		subIndx := hh.Index()
		num := uint64(len(r.PrepareMessages))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range r.PrepareMessages {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the RoundChangeTrace object
func (r *RoundChangeTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(r)
}

// MarshalSSZ ssz marshals the ProposalTrace object
func (p *ProposalTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the ProposalTrace object to a target array
func (p *ProposalTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(64)

	// Field (0) 'Round'
	dst = ssz.MarshalUint64(dst, p.Round)

	// Field (1) 'BeaconRoot'
	dst = append(dst, p.BeaconRoot[:]...)

	// Field (2) 'Signer'
	dst = ssz.MarshalUint64(dst, uint64(p.Signer))

	// Field (3) 'ReceivedTime'
	dst = ssz.MarshalTime(dst, p.ReceivedTime)

	// Offset (4) 'RoundChanges'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(p.RoundChanges); ii++ {
		offset += 4
		offset += p.RoundChanges[ii].SizeSSZ()
	}

	// Offset (5) 'PrepareMessages'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.PrepareMessages) * 56

	// Field (4) 'RoundChanges'
	if size := len(p.RoundChanges); size > 13 {
		err = ssz.ErrListTooBigFn("ProposalTrace.RoundChanges", size, 13)
		return
	}
	{
		offset = 4 * len(p.RoundChanges)
		for ii := 0; ii < len(p.RoundChanges); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += p.RoundChanges[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(p.RoundChanges); ii++ {
		if dst, err = p.RoundChanges[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (5) 'PrepareMessages'
	if size := len(p.PrepareMessages); size > 13 {
		err = ssz.ErrListTooBigFn("ProposalTrace.PrepareMessages", size, 13)
		return
	}
	for ii := 0; ii < len(p.PrepareMessages); ii++ {
		if dst, err = p.PrepareMessages[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ProposalTrace object
func (p *ProposalTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 64 {
		return ssz.ErrSize
	}

	tail := buf
	var o4, o5 uint64

	// Field (0) 'Round'
	p.Round = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'BeaconRoot'
	copy(p.BeaconRoot[:], buf[8:40])

	// Field (2) 'Signer'
	p.Signer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[40:48]))

	// Field (3) 'ReceivedTime'
	p.ReceivedTime = ssz.UnmarshalTime(buf[48:56])

	// Offset (4) 'RoundChanges'
	if o4 = ssz.ReadOffset(buf[56:60]); o4 > size {
		return ssz.ErrOffset
	}

	if o4 < 64 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (5) 'PrepareMessages'
	if o5 = ssz.ReadOffset(buf[60:64]); o5 > size || o4 > o5 {
		return ssz.ErrOffset
	}

	// Field (4) 'RoundChanges'
	{
		buf = tail[o4:o5]
		num, err := ssz.DecodeDynamicLength(buf, 13)
		if err != nil {
			return err
		}
		p.RoundChanges = make([]*RoundChangeTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if p.RoundChanges[indx] == nil {
				p.RoundChanges[indx] = new(RoundChangeTrace)
			}
			if err = p.RoundChanges[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (5) 'PrepareMessages'
	{
		buf = tail[o5:]
		num, err := ssz.DivideInt2(len(buf), 56, 13)
		if err != nil {
			return err
		}
		p.PrepareMessages = make([]*MessageTrace, num)
		for ii := 0; ii < num; ii++ {
			if p.PrepareMessages[ii] == nil {
				p.PrepareMessages[ii] = new(MessageTrace)
			}
			if err = p.PrepareMessages[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ProposalTrace object
func (p *ProposalTrace) SizeSSZ() (size int) {
	size = 64

	// Field (4) 'RoundChanges'
	for ii := 0; ii < len(p.RoundChanges); ii++ {
		size += 4
		size += p.RoundChanges[ii].SizeSSZ()
	}

	// Field (5) 'PrepareMessages'
	size += len(p.PrepareMessages) * 56

	return
}

// HashTreeRoot ssz hashes the ProposalTrace object
func (p *ProposalTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the ProposalTrace object with a hasher
func (p *ProposalTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Round'
	hh.PutUint64(p.Round)

	// Field (1) 'BeaconRoot'
	hh.PutBytes(p.BeaconRoot[:])

	// Field (2) 'Signer'
	hh.PutUint64(uint64(p.Signer))

	// Field (3) 'ReceivedTime'
	hh.PutUint64(uint64(p.ReceivedTime.Unix()))

	// Field (4) 'RoundChanges'
	{
		subIndx := hh.Index()
		num := uint64(len(p.RoundChanges))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range p.RoundChanges {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (5) 'PrepareMessages'
	{
		subIndx := hh.Index()
		num := uint64(len(p.PrepareMessages))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range p.PrepareMessages {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ProposalTrace object
func (p *ProposalTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}

// MarshalSSZ ssz marshals the MessageTrace object
func (m *MessageTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(m)
}

// MarshalSSZTo ssz marshals the MessageTrace object to a target array
func (m *MessageTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Round'
	dst = ssz.MarshalUint64(dst, m.Round)

	// Field (1) 'BeaconRoot'
	dst = append(dst, m.BeaconRoot[:]...)

	// Field (2) 'Signer'
	dst = ssz.MarshalUint64(dst, uint64(m.Signer))

	// Field (3) 'ReceivedTime'
	dst = ssz.MarshalTime(dst, m.ReceivedTime)

	return
}

// UnmarshalSSZ ssz unmarshals the MessageTrace object
func (m *MessageTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 56 {
		return ssz.ErrSize
	}

	// Field (0) 'Round'
	m.Round = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'BeaconRoot'
	copy(m.BeaconRoot[:], buf[8:40])

	// Field (2) 'Signer'
	m.Signer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[40:48]))

	// Field (3) 'ReceivedTime'
	m.ReceivedTime = ssz.UnmarshalTime(buf[48:56])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the MessageTrace object
func (m *MessageTrace) SizeSSZ() (size int) {
	size = 56
	return
}

// HashTreeRoot ssz hashes the MessageTrace object
func (m *MessageTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(m)
}

// HashTreeRootWith ssz hashes the MessageTrace object with a hasher
func (m *MessageTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Round'
	hh.PutUint64(m.Round)

	// Field (1) 'BeaconRoot'
	hh.PutBytes(m.BeaconRoot[:])

	// Field (2) 'Signer'
	hh.PutUint64(uint64(m.Signer))

	// Field (3) 'ReceivedTime'
	hh.PutUint64(uint64(m.ReceivedTime.Unix()))

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the MessageTrace object
func (m *MessageTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(m)
}

// MarshalSSZ ssz marshals the PartialSigMessageTrace object
func (p *PartialSigMessageTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the PartialSigMessageTrace object to a target array
func (p *PartialSigMessageTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Type'
	dst = ssz.MarshalUint64(dst, uint64(p.Type))

	// Field (1) 'BeaconRoot'
	dst = append(dst, p.BeaconRoot[:]...)

	// Field (2) 'Signer'
	dst = ssz.MarshalUint64(dst, uint64(p.Signer))

	// Field (3) 'ReceivedTime'
	dst = ssz.MarshalTime(dst, p.ReceivedTime)

	return
}

// UnmarshalSSZ ssz unmarshals the PartialSigMessageTrace object
func (p *PartialSigMessageTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 56 {
		return ssz.ErrSize
	}

	// Field (0) 'Type'
	p.Type = spectypes.PartialSigMsgType(ssz.UnmarshallUint64(buf[0:8]))

	// Field (1) 'BeaconRoot'
	copy(p.BeaconRoot[:], buf[8:40])

	// Field (2) 'Signer'
	p.Signer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[40:48]))

	// Field (3) 'ReceivedTime'
	p.ReceivedTime = ssz.UnmarshalTime(buf[48:56])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the PartialSigMessageTrace object
func (p *PartialSigMessageTrace) SizeSSZ() (size int) {
	size = 56
	return
}

// HashTreeRoot ssz hashes the PartialSigMessageTrace object
func (p *PartialSigMessageTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the PartialSigMessageTrace object with a hasher
func (p *PartialSigMessageTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Type'
	hh.PutUint64(uint64(p.Type))

	// Field (1) 'BeaconRoot'
	hh.PutBytes(p.BeaconRoot[:])

	// Field (2) 'Signer'
	hh.PutUint64(uint64(p.Signer))

	// Field (3) 'ReceivedTime'
	hh.PutUint64(uint64(p.ReceivedTime.Unix()))

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the PartialSigMessageTrace object
func (p *PartialSigMessageTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}

// MarshalSSZ ssz marshals the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the CommitteeDutyTrace object to a target array
func (c *CommitteeDutyTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(120)

	// Offset (0) 'Rounds'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(c.Rounds); ii++ {
		offset += 4
		offset += c.Rounds[ii].SizeSSZ()
	}

	// Offset (1) 'Decideds'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(c.Decideds); ii++ {
		offset += 4
		offset += c.Decideds[ii].SizeSSZ()
	}

	// Field (2) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(c.Slot))

	// Offset (3) 'Post'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(c.Post); ii++ {
		offset += 4
		offset += c.Post[ii].SizeSSZ()
	}

	// Field (4) 'CommitteeID'
	dst = append(dst, c.CommitteeID[:]...)

	// Offset (5) 'OperatorIDs'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.OperatorIDs) * 8

	// Field (6) 'AttestationDataRoot'
	dst = append(dst, c.AttestationDataRoot[:]...)

	// Field (7) 'SyncCommitteeMessageRoot'
	dst = append(dst, c.SyncCommitteeMessageRoot[:]...)

	// Field (0) 'Rounds'
	if size := len(c.Rounds); size > 15 {
		err = ssz.ErrListTooBigFn("CommitteeDutyTrace.Rounds", size, 15)
		return
	}
	{
		offset = 4 * len(c.Rounds)
		for ii := 0; ii < len(c.Rounds); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += c.Rounds[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(c.Rounds); ii++ {
		if dst, err = c.Rounds[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (1) 'Decideds'
	if size := len(c.Decideds); size > 256 {
		err = ssz.ErrListTooBigFn("CommitteeDutyTrace.Decideds", size, 256)
		return
	}
	{
		offset = 4 * len(c.Decideds)
		for ii := 0; ii < len(c.Decideds); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += c.Decideds[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(c.Decideds); ii++ {
		if dst, err = c.Decideds[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (3) 'Post'
	if size := len(c.Post); size > 13 {
		err = ssz.ErrListTooBigFn("CommitteeDutyTrace.Post", size, 13)
		return
	}
	{
		offset = 4 * len(c.Post)
		for ii := 0; ii < len(c.Post); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += c.Post[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(c.Post); ii++ {
		if dst, err = c.Post[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (5) 'OperatorIDs'
	if size := len(c.OperatorIDs); size > 13 {
		err = ssz.ErrListTooBigFn("CommitteeDutyTrace.OperatorIDs", size, 13)
		return
	}
	for ii := 0; ii < len(c.OperatorIDs); ii++ {
		dst = ssz.MarshalUint64(dst, uint64(c.OperatorIDs[ii]))
	}

	return
}

// UnmarshalSSZ ssz unmarshals the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 120 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1, o3, o5 uint64

	// Offset (0) 'Rounds'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 120 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (1) 'Decideds'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (2) 'Slot'
	c.Slot = phase0.Slot(ssz.UnmarshallUint64(buf[8:16]))

	// Offset (3) 'Post'
	if o3 = ssz.ReadOffset(buf[16:20]); o3 > size || o1 > o3 {
		return ssz.ErrOffset
	}

	// Field (4) 'CommitteeID'
	copy(c.CommitteeID[:], buf[20:52])

	// Offset (5) 'OperatorIDs'
	if o5 = ssz.ReadOffset(buf[52:56]); o5 > size || o3 > o5 {
		return ssz.ErrOffset
	}

	// Field (6) 'AttestationDataRoot'
	copy(c.AttestationDataRoot[:], buf[56:88])

	// Field (7) 'SyncCommitteeMessageRoot'
	copy(c.SyncCommitteeMessageRoot[:], buf[88:120])

	// Field (0) 'Rounds'
	{
		buf = tail[o0:o1]
		num, err := ssz.DecodeDynamicLength(buf, 15)
		if err != nil {
			return err
		}
		c.Rounds = make([]*RoundTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if c.Rounds[indx] == nil {
				c.Rounds[indx] = new(RoundTrace)
			}
			if err = c.Rounds[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (1) 'Decideds'
	{
		buf = tail[o1:o3]
		num, err := ssz.DecodeDynamicLength(buf, 256)
		if err != nil {
			return err
		}
		c.Decideds = make([]*DecidedTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if c.Decideds[indx] == nil {
				c.Decideds[indx] = new(DecidedTrace)
			}
			if err = c.Decideds[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (3) 'Post'
	{
		buf = tail[o3:o5]
		num, err := ssz.DecodeDynamicLength(buf, 13)
		if err != nil {
			return err
		}
		c.Post = make([]*CommitteePartialSigMessageTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if c.Post[indx] == nil {
				c.Post[indx] = new(CommitteePartialSigMessageTrace)
			}
			if err = c.Post[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (5) 'OperatorIDs'
	{
		buf = tail[o5:]
		num, err := ssz.DivideInt2(len(buf), 8, 13)
		if err != nil {
			return err
		}
		c.OperatorIDs = ssz.ExtendUint64(c.OperatorIDs, num)
		for ii := 0; ii < num; ii++ {
			c.OperatorIDs[ii] = spectypes.OperatorID(ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8]))
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) SizeSSZ() (size int) {
	size = 120

	// Field (0) 'Rounds'
	for ii := 0; ii < len(c.Rounds); ii++ {
		size += 4
		size += c.Rounds[ii].SizeSSZ()
	}

	// Field (1) 'Decideds'
	for ii := 0; ii < len(c.Decideds); ii++ {
		size += 4
		size += c.Decideds[ii].SizeSSZ()
	}

	// Field (3) 'Post'
	for ii := 0; ii < len(c.Post); ii++ {
		size += 4
		size += c.Post[ii].SizeSSZ()
	}

	// Field (5) 'OperatorIDs'
	size += len(c.OperatorIDs) * 8

	return
}

// HashTreeRoot ssz hashes the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the CommitteeDutyTrace object with a hasher
func (c *CommitteeDutyTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Rounds'
	{
		subIndx := hh.Index()
		num := uint64(len(c.Rounds))
		if num > 15 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range c.Rounds {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 15)
	}

	// Field (1) 'Decideds'
	{
		subIndx := hh.Index()
		num := uint64(len(c.Decideds))
		if num > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range c.Decideds {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 256)
	}

	// Field (2) 'Slot'
	hh.PutUint64(uint64(c.Slot))

	// Field (3) 'Post'
	{
		subIndx := hh.Index()
		num := uint64(len(c.Post))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range c.Post {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (4) 'CommitteeID'
	hh.PutBytes(c.CommitteeID[:])

	// Field (5) 'OperatorIDs'
	{
		if size := len(c.OperatorIDs); size > 13 {
			err = ssz.ErrListTooBigFn("CommitteeDutyTrace.OperatorIDs", size, 13)
			return
		}
		subIndx := hh.Index()
		for _, i := range c.OperatorIDs {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(c.OperatorIDs))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(13, numItems, 8))
	}

	// Field (6) 'AttestationDataRoot'
	hh.PutBytes(c.AttestationDataRoot[:])

	// Field (7) 'SyncCommitteeMessageRoot'
	hh.PutBytes(c.SyncCommitteeMessageRoot[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the CommitteePartialSigMessageTrace object
func (c *CommitteePartialSigMessageTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the CommitteePartialSigMessageTrace object to a target array
func (c *CommitteePartialSigMessageTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(60)

	// Field (0) 'Type'
	dst = ssz.MarshalUint64(dst, uint64(c.Type))

	// Field (1) 'BeaconRoot'
	dst = append(dst, c.BeaconRoot[:]...)

	// Field (2) 'Signer'
	dst = ssz.MarshalUint64(dst, uint64(c.Signer))

	// Field (3) 'ReceivedTime'
	dst = ssz.MarshalTime(dst, c.ReceivedTime)

	// Offset (4) 'Messages'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.Messages) * 48

	// Field (4) 'Messages'
	if size := len(c.Messages); size > 15 {
		err = ssz.ErrListTooBigFn("CommitteePartialSigMessageTrace.Messages", size, 15)
		return
	}
	for ii := 0; ii < len(c.Messages); ii++ {
		if dst, err = c.Messages[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the CommitteePartialSigMessageTrace object
func (c *CommitteePartialSigMessageTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 60 {
		return ssz.ErrSize
	}

	tail := buf
	var o4 uint64

	// Field (0) 'Type'
	c.Type = spectypes.PartialSigMsgType(ssz.UnmarshallUint64(buf[0:8]))

	// Field (1) 'BeaconRoot'
	copy(c.BeaconRoot[:], buf[8:40])

	// Field (2) 'Signer'
	c.Signer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[40:48]))

	// Field (3) 'ReceivedTime'
	c.ReceivedTime = ssz.UnmarshalTime(buf[48:56])

	// Offset (4) 'Messages'
	if o4 = ssz.ReadOffset(buf[56:60]); o4 > size {
		return ssz.ErrOffset
	}

	if o4 < 60 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (4) 'Messages'
	{
		buf = tail[o4:]
		num, err := ssz.DivideInt2(len(buf), 48, 15)
		if err != nil {
			return err
		}
		c.Messages = make([]*PartialSigMessage, num)
		for ii := 0; ii < num; ii++ {
			if c.Messages[ii] == nil {
				c.Messages[ii] = new(PartialSigMessage)
			}
			if err = c.Messages[ii].UnmarshalSSZ(buf[ii*48 : (ii+1)*48]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the CommitteePartialSigMessageTrace object
func (c *CommitteePartialSigMessageTrace) SizeSSZ() (size int) {
	size = 60

	// Field (4) 'Messages'
	size += len(c.Messages) * 48

	return
}

// HashTreeRoot ssz hashes the CommitteePartialSigMessageTrace object
func (c *CommitteePartialSigMessageTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the CommitteePartialSigMessageTrace object with a hasher
func (c *CommitteePartialSigMessageTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Type'
	hh.PutUint64(uint64(c.Type))

	// Field (1) 'BeaconRoot'
	hh.PutBytes(c.BeaconRoot[:])

	// Field (2) 'Signer'
	hh.PutUint64(uint64(c.Signer))

	// Field (3) 'ReceivedTime'
	hh.PutUint64(uint64(c.ReceivedTime.Unix()))

	// Field (4) 'Messages'
	{
		subIndx := hh.Index()
		num := uint64(len(c.Messages))
		if num > 15 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range c.Messages {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 15)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the CommitteePartialSigMessageTrace object
func (c *CommitteePartialSigMessageTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the PartialSigMessage object
func (p *PartialSigMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the PartialSigMessage object to a target array
func (p *PartialSigMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'BeaconRoot'
	dst = append(dst, p.BeaconRoot[:]...)

	// Field (1) 'Signer'
	dst = ssz.MarshalUint64(dst, uint64(p.Signer))

	// Field (2) 'ValidatorIndex'
	dst = ssz.MarshalUint64(dst, uint64(p.ValidatorIndex))

	return
}

// UnmarshalSSZ ssz unmarshals the PartialSigMessage object
func (p *PartialSigMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 48 {
		return ssz.ErrSize
	}

	// Field (0) 'BeaconRoot'
	copy(p.BeaconRoot[:], buf[0:32])

	// Field (1) 'Signer'
	p.Signer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[32:40]))

	// Field (2) 'ValidatorIndex'
	p.ValidatorIndex = phase0.ValidatorIndex(ssz.UnmarshallUint64(buf[40:48]))

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the PartialSigMessage object
func (p *PartialSigMessage) SizeSSZ() (size int) {
	size = 48
	return
}

// HashTreeRoot ssz hashes the PartialSigMessage object
func (p *PartialSigMessage) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the PartialSigMessage object with a hasher
func (p *PartialSigMessage) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'BeaconRoot'
	hh.PutBytes(p.BeaconRoot[:])

	// Field (1) 'Signer'
	hh.PutUint64(uint64(p.Signer))

	// Field (2) 'ValidatorIndex'
	hh.PutUint64(uint64(p.ValidatorIndex))

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the PartialSigMessage object
func (p *PartialSigMessage) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}
